<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>muTimer</title>
	
	<link rel="icon" href="icons/favicon.svg" type="image/svg+xml">
	
	<!-- Apple Touch Icons (разные размеры для разных устройств) -->
	<link rel="apple-touch-icon" href="icons/apple-touch-icon-180x180.png" sizes="180x180">
	<link rel="apple-touch-icon" href="icons/apple-touch-icon-167x167.png" sizes="167x167">
	<link rel="apple-touch-icon" href="icons/apple-touch-icon-152x152.png" sizes="152x152">
	<link rel="apple-touch-icon" href="icons/apple-touch-icon-120x120.png" sizes="120x120">
	
	<!-- Манифест веб-приложения -->
	<link rel="manifest" href="manifest.json">
	
	<!-- Шрифты -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">

	<link rel="preload" href="/timer/index.html" as="document" fetchpriority="high">
	<style>
		:root {
			--bg-color: #000;
			--bg-color-alt: #011b1c;
			--bg-color-alt-2: #1c0101;
			--text-color: #fff;
			--red900: #7A0919;
			--red600: #DB3323;
			--red500: #FF5230;
			--red100: #FFCCAC;
			--green600: #30DA98;
			--green400: #71FEAB;
			--green900: #0C7970;
			--green1000: #042d29;
			--border-color: rgba(255,255,255,.2);
			--border-red: var(--red900);
			--border-green: var(--green900);
			--grey40: rgba(255,255,255,.4);
			--menu-bg: var(--bg-color-alt);
			--divider: rgba(255,255,255,.1);
			--divider2: rgba(255,255,255,.15);
			--shadow: rgba(0,0,0,.5);

			--radius-outer: 24px;
			--gap: 4vw;
			--gap-mid: 2vw;           
		}

		.night {
			--bg-color: #000;
			--bg-color-alt: #300000;
			--bg-color-alt-2: #300000;
			--text-color: var(--red100);
			--red900: #7A0000;
			--red600: #DB0000;
			--red500: #FF0000;
			--red100: #FF0000;
			--green600: var(--red600);
			--green400: var(--red500);
			--green900: var(--red900);
			--green1000: #500000;
			--border-color: rgba(255,0,0,.2);
			--border-red: var(--red900);
			--border-green: var(--green900);
			--grey40: rgba(255,0,0,.4);
			--menu-bg: var(--bg-color-alt);
			--divider: rgba(255,0,0,.1);
			--divider2: rgba(255,0,0,.15);
			--shadow: rgba(0,0,0,.5);
		}

		html {
			height: 100%;
		}

		body, button {
			font-family: "IBM Plex Sans", sans-serif;
		}

		body {
			font-family: "IBM Plex Sans", sans-serif;
			font-weight: 300;
			background-color: var(--bg-color);
			color: var(--text-color);
			display: flex;
			flex-direction: column;
			padding: 4vw;
			overflow: hidden;
		}
		
		label {
			font-size: 32px;
			line-height: 40px;
			display: flex;
			width: 100%;
			justify-content: space-between;
		}

		.average {
			color: var(--red900);
		}

		input {
			width: 100%;
			font-family: "IBM Plex Sans", serif;
			font-weight: 100;
			padding: 0 0 8px 0;
			height:136px;
			margin: 16px 0;
			box-sizing: border-box;
			border: 0;
			border-radius: var(--radius-outer);
			font-size: 144px;
			text-align: center;
			background-color: transparent;
			outline: 0 solid var(--green400);
			transition: all .2s ease;
		}

		input::placeholder {
			color: var(--grey40);

		}

		button {
			padding: 16px 8vw;
			background: var(--green400);
			color: var(--green900);
			border: none;
			border-radius: var(--radius-outer);
			cursor: pointer;
			transition: opacity 0.3s;
			font-size: 32px;
			line-height: 40px;
			font-weight: 500;
			width: fit-content;
		}

		button:active {
			opacity: 0.8;
		}

		label.green500 {
			color: var(--green600);
		}

		label.red600, h4 {
			color: var(--red600);
		}

		input#totalTime {
			color: var(--green400);
			border-color: var(--green900);
			background-color: var(--bg-color-alt);
		}

		input#totalTime:focus {
			outline: 4px solid var(--green400);
			border-color: transparent;
		}

		input#totalTime::placeholder {
			color: var(--green900);
		}

		input#numTracks {
			color: var(--red600);
			border-color: var(--red900);
			background-color: var(--bg-color-alt-2);
		}

		input#numTracks:focus {
			outline: 4px solid var(--red500);
			border-color: transparent;
		}

		input#numTracks::placeholder {
			color: var(--red900);
		}

		.go {
			width: 100%;
		}

		h4 {
			font-size: 4vw;
			line-height: 8vw;
			font-weight: 400;
			margin: 0;
		}

		h2, h3 {
			margin-bottom: 4px;
			color: var(--green400);
			
		}

		h2 {
			font-size: 3em;
			font-weight: 300;
		}


		h1 {
			padding: 0;
			font-weight: 400;
			margin-top: 0;
			margin-bottom: 0;
			font-size: 16px;
			color: var(--grey40);
		}

		h1.apptitle {
			position: relative;
			top: 16px;
			margin-bottom: 44px;
		}

		p, li {
			font-size: 16px;
		}

		a {
			color: var(--green400);
		}

		hr {
			border: 1px solid var(--divider);
		}

		.form-direction {
			display: flex;
			flex-direction: column;
			gap: var(--gap);
			margin-top: 8px;
			margin-bottom: 32px;
		}

		.status-bar {
			display: flex;
			flex-direction: row;
			gap: var(--gap);
			align-items: center;
		}

		#trackDuration {
			color: var(--green600);
		}

		.input-group {
			
		}

		.curTrack {
			font-size: 48px;
		}

		.trkCount {
			font-size: 20px;
		}

		.blink {
			animation: blink .3s ease-in-out infinite;
			color: var(--red500) !important;
		}

		.timer.main.blink {
			text-shadow: 0 0 16px var(--red500) !important;			
		}

		.blink-pb {
			animation: blink-pb .3s ease-in-out infinite;
			color: var(--red500) !important;
		}

		.trackTimerFrame {
			display: flex;
			flex-direction: column;
			width: 100%;
			gap: var(--gap);
		}

		.perfTimerFrame {
			display: flex;
			flex-direction: column;
			width: 100%;
			gap: var(--gap);
		}

		.row {
			display: flex;
			flex-direction: row;
		}

		.column {
			width: 100%;
		}

		.timer-container {
			margin: 0 0 24px 0;
			display: flex;
			flex-direction: column;
			gap: var(--gap);
		}
		
		/*Таймеры*/
		.timer {
			margin: 16px 0;
			letter-spacing: 2px;
		}

		.timer.main {
			font-size: 32vw;
			line-height: 36vw;
			font-weight: 100;
			color: var(--green400);
			text-shadow: 0 0 16px var(--green400);
		}

		.timer.secondary {
			font-size: 12vw;
			line-height: 16vw;
			font-weight: 300;
			color: var(--red900);
		}
		
		/*Прогресс бары*/
		.progress-container {
			height: 48px;
			background: var(--divider);
			border-radius: var(--radius-outer);
			overflow: hidden;
			position: relative;
			box-shadow: 0px 4px 8px var(--shadow) inset;
		}

		.progress-container .progress-line {
			position: absolute;
			width: 100%;
			height: 2px;
			top: 50%;
			transform: translateY(-50%);
		}

		#trackProgressContainer .progress-line {
			background-color: var(--green400);
		}

		#totalProgressContainer .progress-line {
			background-color: var(--red500);
		}

		.progress-container.total-pb {
			height: fit-content;
		}

		.progress-bar {
			height: 100%;
			position: absolute;
			top:0;
			left: 0;

		}

		#trackProgress {
			background: var(--green400);
		}

		#currentTrack {
			margin: 16px 0;
			color: var(--green400);
		}

		/*Кнопки*/
		#resetBtn {
			background: var(--red500);
			color: var(--red100);
			margin: 0 0 32px 0;
		}

		#nextTrackBtn {
			background-color: var(--red900);
			color: var(--red500);
		}

		#nextTrackBtn:disabled {
			opacity: .2;
			background-color: var(--green900);
			color: var(--green400);
		}

		/* Статус управления подсветкой и статус сети*/
		#wakeLockStatus, #connectionStatus {
			font-size: 16px;
			color: var(--green400);
			font-variant-emoji: text;
		}

		/* Стили для бургер-меню */
		.burger-menu {
			position: fixed;
			top: 8vw;
			right: 8vw;
			z-index: 1000;
		}

		.burger-icon {
			cursor: pointer;
			font-size: 24px;
			line-height: 24px;
			color: var(--grey40);
			padding: 2vw;
			transition: transform 0.3s;
		}

		.menu-content {
			display: none;
			position: absolute;
			left: 0;
			right: 0;
			bottom: 0;
			background: var(--menu-bg);
			border-radius: var(--radius-outer) var(--radius-outer) 0 0;
			padding: 8vw;
			z-index: 1000;
		}

		.menu-container {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.menu-content.show {
			display: block;
			animation: slideDown 0.3s ease;
		}

		.menu-panel {
			display: flex;
			flex-direction: row;
			padding-bottom: 16px;
			border-bottom: 1px solid var(--divider);
			margin-bottom: 16px;
		}

		#hiddenResetBtn {
			background: var(--red500);
			line-height: 24px;
			border: 1px solid var(--border-red);
			color: var(--red900);
			padding: 8px 16px;
			font-size: 16px;
			margin: 0;
			transition: all 0.3s;
			text-wrap: nowrap;
			font-variant-emoji: text;
		}

		button.other {
			background: transparent;
			color: var(--green400);
			font-size: 16px;
			line-height: 44px;
			padding: 8px 16px;
			width: 100%;
			text-align: left;
			font-variant-emoji: text;
		}

		button.other:active {
			background-color: var(--grey40);
		}
		
		/* Затемнение фона при открытом меню */
		.menu-backdrop {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0,0,0,0.5);
			display: none;
			z-index: 999;
		}


		.about, .help, .settings {
			display: none;
			flex-direction: column;
			position: absolute;
			top: 4vw;
			bottom: 4vw;
			left: 4vw;
			right: 4vw;
			border-radius: var(--radius-outer);
			padding: 8vw;
			background: var(--menu-bg);
			z-index: 1002;
			overflow-y: auto;
			gap: var(--gap);
			font-variant-emoji: text;
		}

		.close {
			position: fixed;
			display: block;
			right: 5vw;
			top: 5vw;
			width: 48px;
			height: 48px;
			font-size: 48px;
			text-align: center;
			vertical-align: middle;
			line-height: 48px;
			color: var(--green400);
		}

		.about.show, .help.show, .settings.show {
			display: flex;
		}

		.typo-block {
			width: 100%;
			height: fit-content;
		}

		.help img {
			width: 72px;
			height: 72px;
		}

		/*Чипы пресетов*/
		.shortcuts {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: left;
			gap: 16px;
		}

		.chips-container {
			margin: 16px 0;
			display: flex;
			flex-direction: row;
			gap: 8px;
		}

		.chips-container .chip {
			width: fit-content;
			display: inline-block;
		}

		.chip, .selector, .preset {
			font-size: 20px;
			line-height: 24px;
			font-weight: 400;
			padding: 8px 16px;
			background-color: var(--green1000);
			color: var(--green400);
			border-radius: var(--radius-outer);
			height: fit-content;
			white-space: nowrap;
		}

		.red .preset {
			background-color: var(--red900);
			color: var(--red500);
		}

		.preset.active {
			background: var(--red500);
			color: var(--red900);
		}

		.chip.active {
			background: var(--green600);
			color: var(--green900);
		}

		.spacer {
			height: 24px;
		}

		/*Переключатель языков*/
		.lang-switcher {
			display: flex;
			gap: 8px;
			width: fit-content;
		}

		.lang-btn {
			padding: 8px 16px;
			border-radius: 20px;
			background: var(--surface-300);
			border: none;
			color: var(--text-secondary);
			cursor: pointer;
			transition: all 0.3s;
		}

		.lang-btn.active {
			background: var(--green900);
			color: var(--green400);
		}

		.hor-spacer {
			display: inline-block;
			width: 100%;
		}

		.lic {
			font-size: 12px;
			line-height: 16px;
			color: var(--grey40);
		}


		/* Диалоги */

		.dialog-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.7);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 2000;
			animation: fadeIn 0.3s;
		}

		.dialog-container {
			background: var(--bg-color-alt);
			border-radius: var(--radius-outer);
			padding: 24px;
			min-width: 280px;
			max-width: 90vw;
			transform: scale(0.9);
			margin: 48px;
			animation: scaleUp 0.2s forwards;
		}

		.dialog-content p {
			font-size: 8vw;
			margin: 0 0 24px;
			line-height: 10vw;
		}

		.dialog-buttons {
			display: flex;
			gap: var(--gap);
			justify-content: flex-end;
			flex-direction: column-reverse;
		}

		.dialog-buttons button {
			width: 100%;
			padding: 8px 20px;
			border-radius: 20px;
			border: none;
			cursor: pointer;
			font-size: 4vw;
			transition: opacity 0.2s;
		}

		#dialogConfirm {
			background: var(--green1000);
			color: var(--green400); 
		}

		#dialogCancel {
			background: var(--bg-color);
			color: var(--green400);
		}

		/*ТОЧКИ*/
		
		.tracks-progress {
			position: relative;
			z-index: 100;
			width: 100%;
		}

		.tracks-container {
			display: flex;
			gap: 0;
			flex-wrap: wrap;
			justify-content: space-evenly;
			align-items: center;
			padding: 8px 8px;
		}

		.track-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: var(--green1000);
			transition: all 0.3s ease;
			position: relative;
		}

		.track-dot.past {
			background: var(--red900);
			transition: transform 2s ease-in-out;
		}

		.track-dot.current {
			background: var(--red100);
/*		    box-shadow: 0 0 12px var(--red100);*/
			transform: scale(1.61);
			animation: blink 1s infinite;
		}

		.track-dot.current + .track-dot, .track-dot.past:has(+.track-dot.current)  {
			transform: scale(1.16);
		}

		.night .track-dot.current {
			background: var(--red600);
		}

		/* Анимации */

		/* Диалоги */
		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}

		@keyframes scaleUp {
			to { transform: scale(1); }
		}	


		/*Мигание*/
		@keyframes blink {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.3; }
		}

		@keyframes blink-pb {
			0%, 100% { background-color: var(--divider2); }
			50% { background-color: var(--divider); }
		}

		/*Меню*/
		@keyframes slideDown {
			from {
				opacity: 0;
				transform: translateY(16px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		@keyframes gradient-flow {
			0% { background-position: 0% 50%; }
			50% { background-position: 100% 50%; }
			100% { background-position: 0% 50%; }
		}

		@keyframes shine {
			0% { transform: translateX(-100%); }
			100% { transform: translateX(200%); }
		}


		@media (orientation: landscape)  {
			body {
				flex-direction: row;
				padding: 0;
				align-items: center;
				justify-content: center;
				height: 100%;
			}

			label {
				font-size: 3vw;
				line-height: 2vw;
			}

			button {
				padding: 16px 4vw;
			}

			#configForm {
				margin-right: 8vw
			}

			.form-direction {
				display: flex;
				flex-direction: row;
				gap: var(--gap-mid);
				margin-bottom: 24px;
			}

			.row {
				flex-direction: column;
			}

			.trackTimerFrame {
				width: 61vw;
			}

			.perfTimerFrame {
				width: 28vw;
				gap: var(--gap-mid);
				justify-content: space-between;
			}

			.timer {
				margin: 0;
			}

			.timer.main {
				font-size: 20vw;
				line-height: 20vw;
				display: inline-block;
				width: 100%;
				text-align: center;

			}

			.burger-menu {
				top: 1vw;
				right: 1vw;
			}

			.timer.secondary {
				font-size: 6vw;
				line-height: 8vw;
			}

			h4 {
				font-size: 2vw;
				line-height: 2vw;
			}
			
			h1 {
				display: none;
			}

			.timer-container {
				flex-direction: row;
				gap: var(--gap);
			}

			#nextTrackBtn, .total-pb.total-pb {
/*				height: 100%;*/
			}

			.spacer {
				display: none;
			}

			.menu-content {
				left: 56vw;
				right: 2vw;
				padding: 2vw;
			}

			.help {
				flex-direction: row;
				gap: 2vw;
				padding: 4vw;
			}

			.dialog-content p {
				font-size: 4vw;
				line-height: 6vw;
			}

			.dialog-buttons {
				gap: var(--gap-mid);
				flex-direction: row;
			}

			.dialog-buttons button {
				font-size: 2vw;
			}


			.about, .help, .settings {
				padding: 4vw;
			}

		}

/*		Десктопы*/

		@media (min-width: 1024px) and (hover: hover) and (pointer: fine), (orientation: landscape) and (hover: hover) and (pointer: fine) {
			.form-direction {
				flex-direction: column;
			}

			#configForm {
				margin: 0 24vw;
			}

			.apptitle {
				display: block;
			}

			.menu-content {
				left: 56vw;
				right: 2vw;
				padding: 2vw;
				top: 8vw;
				bottom: auto;
				border-radius: var(--radius-outer);
			}


		}

	</style>
		</head>
		<body>
		<!-- Бургер меню -->
		<div class="burger-menu">
			<div class="burger-icon" onclick="toggleMenu()">☰</div>
		</div>
		<div class="menu-content">
			<div class="menu-container">
				<div class="menu-panel"><button id="hiddenResetBtn" onclick="handleReset()" data-i18n="reset">Reset</button><span class="hor-spacer"></span></div>
				<button class="other" data-i18n="settings" onClick="toggleMenu(); toggleSettings();">Settings</button>
				<button class="other" data-i18n="help" onClick="toggleMenu(); toggleHelp();">Help</button>
				<button class="other" data-i18n="about" onClick="toggleMenu(); toggleAbout();">About</button>
				<button class="other" data-i18n="donate" onClick="location.href='https://www.donationalerts.com/r/annabiosis'" type="button">Donate</button>
			</div>
		</div>
		<div class="about">
			<div class="close" onClick="toggleAbout();">×</div>
			<div class="typo-block">
				<h2>muTimer</h2>
				<p data-i18n="about01">Контролируй время каждого трека и всего выступления целиком.</p>
				<h3 data-i18n="about02">Возможности</h3>
				<ul>
				  <li data-i18n="about03">Автоматическое разделение общего времени на равные отрезки</li>
				  <li data-i18n="about04">Пересчет продолжительности при досрочном переходе</li>
				  <li data-i18n="about05">Работа в фоне и оффлайн</li>
				  <li data-i18n="about06">Визуализация прогресса с подсказками</li>
				  <li data-i18n="about15">Ночная тема</li>
				</ul>
				<h3 data-i18n="about07">Преимущества</h3>
				<ul>
				  <li data-i18n="about08">Не требует установки — работает в браузере</li>
				  <li data-i18n="about09">Сохраняет данные при случайном закрытии</li>
				  <li data-i18n="about10">Автоматическая локализация</li>
				  <li data-i18n="about11">Блокировка спящего режима</li>
				</ul>
				<h3 data-i18n="about12">Технологии</h3>
				<p data-i18n="about13">Использует современные PWA-стандарты для кроссплатформенной работы. Сохрани ярлык на главный экран — получишь полноценное приложение.</p>
				<h3 data-i18n="about14">Разработка</h3>
				<p><a href="https://www.youtube.com/@Annabiosis" target="_blank" data-i18n="authorlink">Annabiosis и Синтезаторы</a></p>
				<p class="lic" data-i18n="lic01">This software uses the IBM Plex Sans typeface. IBM Plex Sans © 2017-2020 IBM Corporation, under the SIL Open Font License 1.1. For details, see: <a href='https://github.com/IBM/plex'>https://github.com/IBM/plex</a></p>
			</div>
		</div>

		<div class="help">
			<div class="close" onClick="toggleHelp();">×</div>
			<div class="typo-block">
				<h2 data-i18n="help">Помощь</h2>
				<p><strong data-i18n="skip">Пропуск</strong> — <span data-i18n="help01">нажимайте, если решили закончить трек раньше. В других случаях нажимать не требуется</span></p>
				<p><strong data-i18n="reset">Сброс</strong> — <span data-i18n="help02">полностью сбрасывает активный таймер и все сохраненные данные</span></p>
<!-- 			<h3 data-i18n="statuses">Статусы</h3>
				<p><span data-i18n="help03">💡 — статус успешного управления подсветкой</span></p>
				<p><span data-i18n="help04">📡 — статус интернет-соединения</span></p> -->
				<h3 data-i18n="tips">Советы</h3>
				<p data-i18n="tips01">Если вам нужен только прогресс всего лайва, вводите время лайва и 1 трек</p>
				<p data-i18n="tips02">Если собираетесь выступать, где не ловит интернет, заранее убедитесь что приложение закэшированно и работает оффлайн</p>
				<p data-i18n="tips03">Приложение адаптировано и для горизонтального использования</p>
			</div>
		</div>
		
		<div class="settings">
			<div class="close" onClick="toggleSettings();">×</div>
			<div class="typo-block">
				<h2 data-i18n="settings">Настройки</h2>
					<div class="blink-settings">
						<h3 data-i18n="blinkIn">Мигать за</h3>
						<div class="chips-container">
							<div class="chip" data-i18n="sec30" data-seconds="30">30 c.</div>
							<div class="chip" data-i18n="min1" data-seconds="60">1 м.</div>
							<div class="chip" data-i18n="min15" data-seconds="90">1,5 м.</div>
							<div class="chip" data-i18n="off" data-seconds="0">Выкл</div>
						</div>
						<p data-i18n="blinkhelp">Можно выбрать за сколько времени до конца трека таймер начнет мигать</p>
					</div>
					<hr>
					<div class="night-settings">
						<h3 data-i18n="nightMode">Ночной режим</h3>
						<div class="chips-container">
							<div class="chip" data-i18n="off" data-night="false">Выкл</div>
							<div class="chip" data-i18n="on" data-night="true">Вкл</div>
						</div>
						<p data-i18n="nightHelp">Можно выбрать за сколько времени до конца трека таймер начнет мигать</p>
					</div>
					
			</div>

		</div>

		<!-- Форма конфигурации -->
		<form id="configForm">
			<h1 class="apptitle">muTimer</h1>
			<div class="form-direction">
				<div class="input-group">
					<label class="green500" data-i18n="totalDuration">Set Duration (min)</label>
					<input type="number" id="totalTime" placeholder="0" pattern="[0-9]*" inputmode="numeric" required>
					<div class="shortcuts">
						<div class="chip" data-minutes="30">30′</div>
						<div class="chip" data-minutes="60">60′</div>
						<div class="chip" data-minutes="90">90′</div>
						<div class="chip" data-minutes="120">120′</div>
					</div>
				</div>
				<div class="input-group">
					<label class="red600"><span data-i18n="tracks">Tracks Count</span> <span class="average"><span data-i18n="each">по</span> <span id="averageTimeDisplay">--:--</span></span></label>
					<input type="number" id="numTracks" placeholder="0" pattern="[0-9]*" inputmode="numeric" required>
					<div class="shortcuts red" id="trackPresets"></div>
				</div>
			</div>
			<button type="submit" class="go" data-i18n="start">Go!</button>
		</form>
		<!-- Таймер -->
		<div id="timers" class="timers" style="display: none;">
			<div class="timer-container">
				

				<div class="trackTimerFrame">
					<h4 class="status-bar">
						<span class="curTrack" id="currentTrack"></span>/<span class="trkCount" id="trackCount"></span> <span id="trackDuration"></span><span id="wakeLockStatus"></span><span id="connectionStatus"></span>
					</h4>
					<div><span id="trackTimer" class="timer main"></span></div>
					<div id="trackProgressContainer" class="progress-container">
						<div id="trackProgress" class="progress-bar"></div>
					</div>
				</div>

				
				<div class="perfTimerFrame">
					<div class="row">
						<div class="column">
							<h4 data-i18n="elapsed">Elapsed</h4>
							<div><span id="elapsedTimer" class="timer secondary"></span></div>
						</div>
						<div class="column">
							<h4 data-i18n="remaining">Remaining</h4>
							<div><span id="remainingTimer" class="timer secondary"></span></div>
						</div>
					</div>
					<div id="totalProgressContainer" class="progress-container total-pb">
						<div class="tracks-progress">
							<div class="tracks-container" id="tracksContainer"></div>
						</div>
						<div id="totalProgress" class="progress-bar" style="background: var(--red500);"></div>
					</div>
					<div class="spacer"></div>
					<button id="nextTrackBtn" onclick="nextTrack()" data-i18n="skip">Skip</button>
				</div>

			</div>
		</div>


		<div class="dialog-overlay" id="dialogOverlay">
			<div class="dialog-container">
				<div class="dialog-content">
					<p id="dialogMessage"></p>
					<div class="dialog-buttons">
						<button id="dialogCancel"></button>
						<button id="dialogConfirm"></button>
					</div>
				</div>
			</div>
		</div>


		<script>
		// Словари переводов
		const i18n = {
			en: {
				totalDuration: "Total duration",
				tracks: "Tracks",
				start: "Start",
				reset: "💀 Reset",
				skip: "Skip",
				currentTrack: "Current track",
				elapsed: "Elapsed",
				remaining: "Remaining",
				confirmReset: "Are you sure you want to reset?",
				performanceEnded: "Performance ended!",
				err_grater: "Enter value gratee than ZERO!",
				about: "About",
				help: "Help", 
				donate: "👍 Support me",
				about01: "Control the timing of each track and the entire performance",
				about02: "Features",
				about03: "Automatic division of total time into equal segments",
				about04: "Recalculation of duration during early transitions",
				about05: "Background and offline operation",
				about06: "Progress visualization with cues",
				about15: "Night Mode",
				about07: "Advantages",
				about08: "No installation required — works in the browser",
				about09: "Saves data on accidental closure",
				about10: "Automatic localization",
				about11: "Sleep mode prevention",
				about12: "Technologies",
				about13: "Uses modern PWA standards for cross-platform functionality. Add to home screen — get a full-fledged app.",
				about14: "Developer", 
				authorlink: "Annabiosis",
				tips: "Tips", 
				help01: "Click if you want to finish the track early. No need to click otherwise",
				help02: "Completely resets the active timer and all saved data",
				statuses: "Statuses", 
				help03: "💡 — screen sleep-mode control status",
				help04: "📡 — internet connection status",
				tips01: "To track only the full session, input total time and select 1 track",
				tips02: "If performing where internet is unavailable, verify the app is cached and functions offline in advance",
				tips03: "The app is fully optimized for landscape mode usage", 
				lic01: "Typeface IBM Plex Sans © 2017-2020 IBM Corporation, under the SIL Open Font License 1.1. For details, see: https://github.com/IBM/plex",
				settings: "Settings",
				blinkIn: "Blink in",
				min2: "2′",
				min15: "1.5′",
				min1: "1′",
				sec30: "30′′",
				blinkhelp: "Set timer blink start time before track ends",
				off: "Off",
				on: "On",
				ok: "OK",
				confirm: "Confirm",
				cancel: "Cancel",
				each: "each",
				nightMode: "Night Mode",
				nightHelp: "Makes the interface red so it doesn't blind your eyes in the dark" 
			},
			ru: {
				totalDuration: "Длительность",
				tracks: "Треков",
				start: "Старт",
				reset: "💀 Сброс",
				skip: "Пропуск",
				currentTrack: "Текущий трек",
				elapsed: "Прошло",
				remaining: "Осталось",
				confirmReset: "Вы уверены, что хотите сбросить таймер?",
				performanceEnded: "Выступление завершено!",
				err_grater:"Введите значение больше НОЛЯ!",
				about:"О приложении",
				help: "Помощь", 
				donate: "👍 Поддержите меня",
				about01: "Контролируй время каждого трека и всего выступления целиком.",
				about02: "Возможности",
				about03: "Автоматическое разделение общего времени на равные отрезки",
				about04: "Пересчет продолжительности при досрочном переходе",
				about05: "Работа в фоне и оффлайн",
				about06: "Визуализация прогресса с подсказками",
				about15: "Ночной режим",
				about07: "Преимущества",
				about08: "Не требует установки — работает в браузере",
				about09: "Сохраняет данные при случайном закрытии",
				about10: "Автоматическая локализация",
				about11: "Блокировка спящего режима",
				about12: "Технологии",
				about13: "Использует современные PWA-стандарты для кроссплатформенной работы. Сохрани ярлык на главный экран — получишь полноценное приложение.",
				about14: "Разработка", 
				authorlink: "Annabiosis",
				tips: "Советы", 
				help01: "нажимайте, если решили закончить трек раньше. В других случаях нажимать не требуется",
				help02: "полностью сбрасывает активный таймер и все сохраненные данные",
				statuses: "Статусы",
				help03: "💡 — статус успешного управления подсветкой",
				help04: "📡 — статус интернет-соединения",  
				tips01: "Если вам нужен только прогресс всего лайва, вводите время лайва и 1 трек",
				tips02: "Если собираетесь выступать, где не ловит интернет, заранее убедитесь, что приложение закэшированно и работает оффлайн",
				tips03: "Приложение адаптировано и для горизонтального использования", 
				lic01: "Шрифт IBM Plex Sans © 2017-2020 IBM Corporation, используется в соответствии с лицензией SIL Open Font License 1.1. Подробнее. For details, see: https://github.com/IBM/plex",
				settings: "Настройки",
				blinkIn: "Мигать за",
				min2: "2′",
				min15: "1,5′",
				min1: "1′",
				sec30: "30′′",
				blinkhelp: "Можно выбрать за сколько времени до конца трека таймер начнет мигать",
				off: "Выкл",
				on: "Вкл",
				ok: "OK",
				confirm: "Подтвердить",
				cancel: "Отмена",
				each: "по",
				nightMode: "Ночной режим",
				nightHelp: "Сделает интерфейс красным, чтобы не слепить глаза в темноте"   
			}
		};


		



		// Диалоги
		class Dialog {
			constructor() {
				this.overlay = document.getElementById('dialogOverlay');
				this.message = document.getElementById('dialogMessage');
				this.confirmBtn = document.getElementById('dialogConfirm');
				this.cancelBtn = document.getElementById('dialogCancel');
				this.initEvents();
			}

			initEvents() {
				this.overlay.addEventListener('click', e => {
					if(e.target === this.overlay) this.hide();
				});
				
				document.addEventListener('keydown', e => {
					if(e.key === 'Escape') this.hide();
				});
			}

			show(options) {
				return new Promise(resolve => {
					this.message.textContent = options.message;
					this.confirmBtn.textContent = options.confirmText || 'OK';
					this.cancelBtn.textContent = options.cancelText || 'Cancel';

					this.confirmBtn.onclick = () => {
						this.hide();
						resolve(true);
					};

					this.cancelBtn.onclick = () => {
						this.hide();
						resolve(false);
					};

					this.cancelBtn.style.display = options.showCancel ? 'block' : 'none';
					this.overlay.style.display = 'flex';
					this.confirmBtn.focus();
				});
			}

			hide() {
				this.overlay.style.display = 'none';
			}
		}


		// Инициализация диалогов
		const customDialog = new Dialog();
		
		// Настройки
		// Инициализация
		let blinkThreshold = localStorage.getItem('blinkThreshold') || 30;
		
		const toggle = document.getElementById('nightModeToggle');
		let isNightMode = localStorage.getItem('nightMode') === 'true';


		function updateTheme() {
			document.body.classList.toggle('night', isNightMode);
		}


		// Обработчики чипов
		document.querySelectorAll('.blink-settings .chip').forEach(chip => {
			chip.addEventListener('click', function() {
				// Удаляем активный класс у всех чипов
				document.querySelectorAll('.blink-settings .chip').forEach(c => 
					c.classList.remove('active')
				);
				
				// Устанавливаем новое значение
				blinkThreshold = parseInt(this.dataset.seconds);
				localStorage.setItem('blinkThreshold', blinkThreshold);
				
				// Добавляем активный класс
				this.classList.add('active');
			});
		});

		// Обработчики чипов
		document.querySelectorAll('.night-settings .chip').forEach(chip => {
			chip.addEventListener('click', function() {
				// Удаляем активный класс у всех чипов
				document.querySelectorAll('.night-settings .chip').forEach(c => 
					c.classList.remove('active')
				);
				
				// Устанавливаем новое значение
				isNightMode = (this.dataset.night === 'true');
				localStorage.setItem('nightMode', isNightMode);
				updateTheme();
				
				// Добавляем активный класс
				this.classList.add('active');
			});
		});

		document.getElementById('totalTime').addEventListener('input', updateTrackPresets);

		// ТОЧКИ
		// Инициализация треков
		function initTracksProgress(totalTracks) {
			const container = document.getElementById('tracksContainer');
			container.innerHTML = '';
			
			for(let i = 1; i <= totalTracks; i++) {
				const dot = document.createElement('div');
				dot.className = 'track-dot';
				dot.dataset.track = i;
				container.appendChild(dot);
			}
		}

		// Обновление состояния
		function updateTracksProgress(currentTrack) {
			const dots = document.querySelectorAll('.track-dot');
			
			dots.forEach((dot, index) => {
				dot.classList.remove('past', 'current');
				
				if(index + 1 < currentTrack) {
					dot.classList.add('past');
				} else if(index + 1 === currentTrack) {
					dot.classList.add('current');
				}
			});
		}

		// Восстановление при загрузке
		document.addEventListener('DOMContentLoaded', () => {
			applyTranslations();
			addLanguageSwitcher();
			updateTrackPresets();
			
			const initialValue = document.getElementById('numTracks').value;
			updateActivePreset(initialValue);
			
			document.querySelectorAll('.blink-settings .chip').forEach(chip => {
				if(parseInt(chip.dataset.seconds) === parseInt(blinkThreshold)) {
					chip.classList.add('active');
				}
			});

			document.querySelectorAll('.night-settings .chip').forEach(chip => {
				
				var nightdata = (chip.dataset.night === "true");
				if(nightdata === isNightMode) {
					chip.classList.add('active');
				}
			});
		});


		function calculateTrackPresets(totalMinutes) {
			const presets = {};
			
			[3, 4, 5, 6].forEach(minutes => {
				const count = Math.round(totalMinutes / minutes);
				presets[minutes] = count > 0 ? count : 1;
			});


			return presets;
		}

		document.getElementById('numTracks').addEventListener('input', function() {
			updateActivePreset(this.value);
		});

		// Функция обновления активного пресета
		function updateActivePreset(currentValue) {
			const chips = document.querySelectorAll('.preset[data-count]');
			
			// Удаляем класс active у всех чипов
			chips.forEach(chip => chip.classList.remove('active'));
			
			// Ищем чип с совпадающим значением
			const activeChip = Array.from(chips).find(chip => 
				parseInt(chip.dataset.count) === parseInt(currentValue)
			);
			
			if(activeChip) {
				activeChip.classList.add('active');
			}
		}


		function calculateAverageTrackTime() {
			const totalMinutes = parseFloat(document.getElementById('totalTime').value) || 0;
			const numTracks = parseInt(document.getElementById('numTracks').value) || 1;
			
			// Расчет в секундах для точности
			const totalSeconds = totalMinutes * 60;
			const averageSeconds = totalSeconds / numTracks;
			
			// Форматирование времени
			const minutes = Math.floor(averageSeconds / 60);
			const seconds = Math.round(averageSeconds % 60);
			
			
			return `${minutes}:${seconds.toString().padStart(2, '0')}`;
		}

		// Функция обновления отображения
		function updateAverageTimeDisplay() {
			const displayElement = document.getElementById('averageTimeDisplay');
			
			if(!displayElement) return;
			
			try {
				displayElement.textContent = calculateAverageTrackTime();
			} catch(e) {
				displayElement.textContent = '--:--';
			}
		}

		function keepFirstUniqueValues(obj) {
		  const seenValues = new Set(); // Для отслеживания уже встреченных значений
		  const result = {};

		  for (const key in obj) {
			const value = obj[key];
			if (!seenValues.has(value)) {
			  seenValues.add(value);
			  result[key] = value;
			}
		  }
		  return result;
		}

		// Функция обновления пресетов
		function updateTrackPresets() {
			const totalMinutes = parseInt(document.getElementById('totalTime').value) || 0;
			const totalTracks = parseInt(document.getElementById('numTracks').value) || 0;
			const presets = calculateTrackPresets(totalMinutes);
			const container = document.getElementById('trackPresets');
			
			const tempSet = keepFirstUniqueValues(presets);;
		   
			if (totalMinutes > 0) {

				container.innerHTML = Object.entries(tempSet)
					.map(([minutes, count]) => `
						<div class="preset" 
							 data-minutes="${minutes}" 
							 data-count="${count}"
							 onclick="document.getElementById('numTracks').value = ${count}; updateAverageTimeDisplay(); updateActivePreset(${count});">${count}
						</div>
					`).join('');
			} else {
				container.innerHTML = '<div class="preset disabled">--</div>';
			}
		}


		// Обновление статуса соединения
		// function updateConnectionStatus() {
		//     const statusElement = document.getElementById('connectionStatus');
		//     const isOnline = navigator.onLine;
		//     const statusText = isOnline ? '📡' : '❗';
		//     statusElement.textContent = statusText;
		// }

		// Определяем язык системы
		const getSystemLanguage = () => {
			const systemLang = navigator.language.split('-')[0];
			return Object.keys(i18n).includes(systemLang) ? systemLang : 'en';
		};

		// Инициализация языка
		let currentLang = localStorage.getItem('appLang') || getSystemLanguage();

		// Функция применения переводов
		function applyTranslations() {
			const elements = document.querySelectorAll('[data-i18n]');
			
			elements.forEach(el => {
				const key = el.dataset.i18n;
				el.textContent = i18n[currentLang][key] || key;
			});
		}

		// Переключатели языков в бургер-меню
		function addLanguageSwitcher() {
			const menu = document.querySelector('.menu-panel');
			const html = `
				<div class="lang-switcher">
					<button class="lang-btn selector ${currentLang === 'en' ? 'active' : ''}" data-lang="en">EN</button>
					<button class="lang-btn selector ${currentLang === 'ru' ? 'active' : ''}" data-lang="ru">RU</button>
				</div>
			`;
			menu.insertAdjacentHTML('beforeend', html);
		}

		// Обработчик смены языка
		document.body.addEventListener('click', e => {
			if(e.target.classList.contains('lang-btn')) {
				currentLang = e.target.dataset.lang;
				localStorage.setItem('appLang', currentLang);
				applyTranslations();
				document.querySelectorAll('.lang-btn').forEach(btn => 
					btn.classList.toggle('active', btn.dataset.lang === currentLang)
				);
			}
		});

		// Алерты
		function showAlert(message) {
			return customDialog.show({
				message: i18n[currentLang][message],
				showCancel: false,
				confirmText: i18n[currentLang].ok
			});
		}

		function showConfirm(message) {
			return customDialog.show({
				message: i18n[currentLang][message],
				showCancel: true,
				confirmText: i18n[currentLang].confirm,
				cancelText: i18n[currentLang].cancel
			});
		}

		// Проверка поддержки Service Worker
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', async () => {
				try {
					const registration = await navigator.serviceWorker.register('/sw.js');
					console.log('ServiceWorker Registered');

					 // Функция для получения версии кеша
					 function getCacheVersion() {
					   return new Promise((resolve, reject) => {
							if (!navigator.serviceWorker.controller) {
								reject('Service Worker не активен');
							   	return;
							}

							const messageChannel = new MessageChannel();
							messageChannel.port1.onmessage = event => {
							resolve(event.data); // Версия кеша из Service Worker
							};
							messageChannel.port1.onerror = error => {
								reject(error);
							}
							navigator.serviceWorker.controller.postMessage('GET_CACHE_VERSION', [messageChannel.port2]);
					   });
					 }

					 // Вызываем функцию для получения версии кеша после регистрации Service Worker
					 getCacheVersion()
					 .then(version => {
						console.log('Версия кеша:', version);
						document.getElementById('cache-version').textContent = `Версия кеша: ${version}`; // Отображаем на странице
					})
						.catch(error => {
							console.error('Ошибка получения версии кеша:', error);
						 	document.getElementById('cache-version').textContent = 'Не удалось получить версию кеша';
					});
					
				} catch (err) {
					console.log('ServiceWorker Registration Error:', err);
				}
			});
		}
















		// Обработчик обновлений
		navigator.serviceWorker.addEventListener('controllerchange', () => {
			window.location.reload();
		});

		let wakeLock = null;
		let intervalId;
		let state = {
			startTime: null,         // Время начала в миллисекундах
			totalDuration: null,     // Общая длительность в миллисекундах
			originalTracks: null,    // Изначальное количество треков
			currentTrack: 1,         // Текущий трек
			spentTimes: []           // Массив времени по трекам
		};
		let isMenuOpen = false;

		function toggleMenu() {
			const menu = document.querySelector('.menu-content');
			let backdrop = document.querySelector('.menu-backdrop');
			
			isMenuOpen = !isMenuOpen;
			
			if(isMenuOpen) {
				menu.classList.add('show');
				if(!backdrop) {
					backdrop = document.createElement('div');
					backdrop.className = 'menu-backdrop';
					backdrop.onclick = toggleMenu;
					document.body.appendChild(backdrop);
				}
				backdrop.style.display = 'block';
			} else {
				menu.classList.remove('show');
				if(backdrop) {
					backdrop.style.display = 'none';
				}
			}
		}

	// Показ информации
		function toggleAbout() {
			const help = document.querySelector('.about');
			let backdrop = document.querySelector('.menu-backdrop');
			
			isMenuOpen = !isMenuOpen;
			
			if(isMenuOpen) {
				help.classList.add('show');
				if(!backdrop) {
					backdrop = document.createElement('div');
					backdrop.className = 'menu-backdrop';
					backdrop.onclick = toggleMenu;
					document.body.appendChild(backdrop);
				}
				backdrop.style.display = 'block';
			} else {
				help.classList.remove('show');
				if(backdrop) {
					backdrop.style.display = 'none';
				}
			}
		}

		// Показ помощи
		function toggleHelp() {
			const help = document.querySelector('.help');
			let backdrop = document.querySelector('.menu-backdrop');
			
			isMenuOpen = !isMenuOpen;
			
			if(isMenuOpen) {
				help.classList.add('show');
				if(!backdrop) {
					backdrop = document.createElement('div');
					backdrop.className = 'menu-backdrop';
					backdrop.onclick = toggleMenu;
					document.body.appendChild(backdrop);
				}
				backdrop.style.display = 'block';
			} else {
				help.classList.remove('show');
				if(backdrop) {
					backdrop.style.display = 'none';
				}
			}
		}

		// Показ помощи
		function toggleSettings() {
			const help = document.querySelector('.settings');
			let backdrop = document.querySelector('.menu-backdrop');
			
			isMenuOpen = !isMenuOpen;
			
			if(isMenuOpen) {
				help.classList.add('show');
				if(!backdrop) {
					backdrop = document.createElement('div');
					backdrop.className = 'menu-backdrop';
					backdrop.onclick = toggleMenu;
					document.body.appendChild(backdrop);
				}
				backdrop.style.display = 'block';
			} else {
				help.classList.remove('show');
				if(backdrop) {
					backdrop.style.display = 'none';
				}
			}
		}

		// Блокировка экрана
		async function requestWakeLock() {
			try {
				if ('wakeLock' in navigator) {
					wakeLock = await navigator.wakeLock.request('screen');
					// document.getElementById('wakeLockStatus').textContent = '💡';
				}
			} catch (err) {
				console.error('Wake Lock Error:', err);
			}
		}

		function releaseWakeLock() {
			if (wakeLock !== null && !wakeLock.released) {
				wakeLock.release();
				wakeLock = null;
			}
		}

		// Форматирование времени
		function formatTime(ms) {
			const totalMs = Math.max(0, ms);
			const totalSeconds = Math.floor(totalMs / 1000);
			const mins = Math.floor(totalSeconds / 60);
			const secs = totalSeconds % 60;
			return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
		}

		// Сохранение состояния
		function saveState() {
			localStorage.setItem('timerState', JSON.stringify(state));
		}

		// Восстановление состояния
		function restoreState() {
			const savedState = localStorage.getItem('timerState');
			if (!savedState) return;

			try {
				const parsed = JSON.parse(savedState);
				const now = Date.now();
				
				// Проверка валидности сохраненных данных
				if (!parsed.startTime || !parsed.totalDuration || !parsed.originalTracks) {
					localStorage.removeItem('timerState');
					return;
				}

				// Проверка не завершено ли выступление
				const timePassed = now - parsed.startTime;
				if (timePassed >= parsed.totalDuration) {
					localStorage.removeItem('timerState');
					return;
				}

				// Восстановление состояния
				state = {
					startTime: parsed.startTime,
					totalDuration: parsed.totalDuration,
					originalTracks: parsed.originalTracks,
					currentTrack: parsed.currentTrack,
					spentTimes: parsed.spentTimes
				};

				// Корректировка текущего трека
				const totalSpent = state.spentTimes.reduce((a, b) => a + b, 0);
				const trackDuration = (state.totalDuration - totalSpent) / 
									(state.originalTracks - state.currentTrack + 1);
				const currentTrackElapsed = timePassed - totalSpent;

				// Автоматический переход завершенных треков
				while (currentTrackElapsed > trackDuration && 
					  state.currentTrack < state.originalTracks) {
					state.spentTimes.push(trackDuration);
					state.currentTrack++;
					totalSpent += trackDuration;
					trackDuration = (state.totalDuration - totalSpent) / 
								  (state.originalTracks - state.currentTrack + 1);
				}
				initTracksProgress(state.originalTracks);
				updateTracksProgress(state.currentTrack)
				saveState(); // Обновляем сохраненное состояние
			} catch (e) {
				console.error('Restoring Error:', e);
				localStorage.removeItem('timerState');
			}
		}

		// Обработчик кнопки "Пропуск"
		function nextTrack() {
			const now = Date.now();
			const totalSpent = state.spentTimes.reduce((a, b) => a + b, 0);
			const currentTrackTime = now - state.startTime - totalSpent;

			if(currentTrackTime <= 0) return;
			
			state.spentTimes.push(currentTrackTime);
			state.currentTrack++;
			
			if(state.currentTrack > state.originalTracks) {
				finishPerformance();
				return;
			}
			
			saveState();
			updateTimers();
			updateTracksProgress(state.currentTrack);
		}

		// Обновление таймеров
		function updateTimers() {
			const now = Date.now();
			const totalElapsed = now - state.startTime;
			
			if(totalElapsed >= state.totalDuration) {
				finishPerformance();
				return;
			}

			// Управление состоянием кнопки
			const nextTrackBtn = document.getElementById('nextTrackBtn');
			const isLastTrack = state.currentTrack === state.originalTracks;
			nextTrackBtn.disabled = isLastTrack;
			const totalSpent = state.spentTimes.reduce((a, b) => a + b, 0);
			const remainingTracks = state.originalTracks - state.currentTrack + 1;
			const trackDuration = (state.totalDuration - totalSpent) / remainingTracks;
			const trackElapsed = totalElapsed - totalSpent;
			let trackRemaining = trackDuration - trackElapsed;
			const shouldBlink = trackRemaining <= blinkThreshold;

			// Автоматический переход при отрицательном времени
			if(trackRemaining <= 0 && remainingTracks > 1) {
				state.spentTimes.push(trackDuration);
				state.currentTrack++;
				saveState();
				updateTracksProgress(state.currentTrack);
				return updateTimers(); // Рекурсивно обновляем
			}

			// Обновление интерфейса
			document.getElementById('currentTrack').textContent = state.currentTrack;
			document.getElementById('trackCount').textContent = `${state.originalTracks}`;
			document.getElementById('trackTimer').textContent = formatTime(trackRemaining);
			document.getElementById('elapsedTimer').textContent = formatTime(totalElapsed);
			document.getElementById('remainingTimer').textContent = formatTime(state.totalDuration - totalElapsed);
			document.getElementById('trackDuration').textContent = formatTime(trackDuration);

			// Прогресс-бары
			const totalProgress = (totalElapsed / state.totalDuration) * 100;
			const trackProgress = (trackElapsed / trackDuration) * 100;
			
			document.getElementById('totalProgress').style.width = `${totalProgress}%`;
			document.getElementById('trackProgress').style.width = `${trackProgress}%`;

			// Мигание
			const trackTimerElement = document.getElementById('trackTimer');
			const trackProgressBar = document.getElementById('trackProgressContainer');
			if (trackRemaining <= blinkThreshold*1000) { // 30 секунд
				trackTimerElement.classList.add('blink');
				trackProgressBar.classList.add('blink-pb');
			} else {
				trackTimerElement.classList.remove('blink');
				trackProgressBar.classList.remove('blink-pb');
			}


		}

		// Завершение выступления
		function finishPerformance() {
			clearInterval(intervalId);
			showAlert('performanceEnded');
			resetApp();
		}

		// Сброс приложения
		function resetApp() {
			const savedThreshold = localStorage.getItem('blinkThreshold');
			clearInterval(intervalId);
			releaseWakeLock();
			localStorage.removeItem('timerState');
			state = {
				startTime: null,
				totalDuration: null,
				originalTracks: null,
				currentTrack: 1,
				spentTimes: []
			};
			document.getElementById('timers').style.display = 'none';
			document.getElementById('configForm').style.display = 'block';
			document.getElementById('nextTrackBtn').disabled = false;

			if(savedThreshold) localStorage.setItem('blinkThreshold', savedThreshold);
			document.getElementById('tracksContainer').innerHTML = '';
			updateTheme();

		}

		function handleReset() {
			toggleMenu(); // Закрываем меню
			showConfirm('confirmReset').then(confirmed => {
				if(confirmed) {
					resetApp(); // Пользователь подтвердил
				}
			});
		}

		// Инициализация формы
		document.getElementById('configForm').addEventListener('submit', (e) => {
			e.preventDefault();
			
			const totalMinutes = parseInt(document.getElementById('totalTime').value);
			const numTracks = parseInt(document.getElementById('numTracks').value);
			
			if(totalMinutes < 1 || numTracks < 1) {
				showAlert('err_grater');
				return;
			}



			state = {
				startTime: Date.now(),
				totalDuration: totalMinutes * 60 * 1000,
				originalTracks: numTracks,
				currentTrack: 1,
				spentTimes: []
			};
			
			saveState();
			requestWakeLock();
			document.getElementById('configForm').style.display = 'none';
			document.getElementById('timers').style.display = 'block';
			intervalId = setInterval(updateTimers, 100);
			updateTimers();
			initTracksProgress(numTracks);
			updateTracksProgress(state.currentTrack);
		});

		// Восстановление при загрузке
		window.addEventListener('load', () => {
			// updateConnectionStatus();
			
			// События изменения состояния
			// window.addEventListener('online', updateConnectionStatus);
			// window.addEventListener('offline', updateConnectionStatus);

			restoreState();
			
			if (state.startTime) {
				const timePassed = Date.now() - state.startTime;
				if (timePassed < state.totalDuration) {
					document.getElementById('configForm').style.display = 'none';
					document.getElementById('timers').style.display = 'block';
					intervalId = setInterval(updateTimers, 100);
					requestWakeLock();
					updateTimers();
				} else {
					resetApp();
				}
			}
		});

		// Обработчик для чипов
		document.querySelectorAll('.shortcuts .chip').forEach(chip => {
			chip.addEventListener('click', function() {
				// Удаляем активный класс у всех чипов
				document.querySelectorAll('.shortcuts .chip').forEach(c => c.classList.remove('active'));
				
				// Устанавливаем значение в поле ввода
				const minutes = this.dataset.minutes;
				document.getElementById('totalTime').value = minutes;
				
				// Добавляем активный класс текущему чипу
				this.classList.add('active');
				
				// Триггерим событие изменения для обновления расчетов
				document.getElementById('totalTime').dispatchEvent(new Event('input'));
			});
		});

		// Сброс чипов при ручном вводе
		document.getElementById('totalTime').addEventListener('input', function() {
			const chips = document.querySelectorAll('.chip');
			const currentValue = this.value;
			updateAverageTimeDisplay();
			
			// Проверяем, совпадает ли значение с чипом
			const activeChip = Array.from(chips).find(chip => 
				chip.dataset.minutes === currentValue
			);
			
			if(!activeChip) {
				chips.forEach(chip => chip.classList.remove('active'));
			}
		});

		document.getElementById('numTracks').addEventListener('input', updateAverageTimeDisplay);

		// Wake Lock при возвращении на вкладку
		document.addEventListener('visibilitychange', () => {
			if(document.visibilityState === 'visible') {
				requestWakeLock();
			}
		});


		updateTheme();
	</script>
</body>
</html>